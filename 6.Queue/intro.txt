What is a Queue?
-> Queue is a data structure that stores items in a First-In/First-Out manner.
-> Utilize first coming data first, while others wait for their turn.
-> FIFO method - First In First Out
-> Call center phone systems

Queue Operations:
i. Create Queue
ii. Enqueue
iii. Dequeue
iv. Peek
v. isEmpty
vi. isFull
vii. deleteQueue

Create Linear Queue With Array:->
public LinearQueue(int size) {
		this.arr = new int[size];
		this.topOfQueue = -1;
		this.beginningOfQueue = -1;
		System.out.println("The Linear Queue is successfully created with size of "+size);
	}

Time Complexity:-> O(1)
Space Complexity:-> O(N)

Checking is full of the Linear Queue with Array:->
public boolean isFull() {
		if(topOfQueue == arr.length - 1) {
			return true;
		}
		else {
			return false;
		}
	}

Time Complexity:-> O(1)
Space Complexity:-> O(1)



Checking is Empty of the Linear Queue with Array:->
public boolean isEmpty() {
		if(beginningOfQueue == -1 || beginningOfQueue == arr.length) {
			return true;
		}
		else {
			return false;
		}
	}

Time Complexity:-> O(1)
Space Complexity:-> O(1)



Inserting Element in Linear Queue:->
public void enQueue(int value) {
		if(isFull()) {
			System.out.println("The Queue is Full!");
		}
		else if(isEmpty()) {
			beginningOfQueue = 0;
			topOfQueue++;
			arr[topOfQueue] = value;
			System.out.println("Successfully inserted "+value+" in the queue");
		}
		else {
			topOfQueue++;
			arr[topOfQueue] = value;
			System.out.println("Successfully inserted "+value+" in the queue");
		}
	}

Time Complexity:-> O(1)
Space Complexity:-> O(1)

Deleting an Element from Linear Queue:->
	public int deQueue() {
		if(isEmpty()) {
			System.out.println("The Queue is empty!");
			return -1; 
		}
		else {
			int result = arr[beginningOfQueue];
			beginningOfQueue++;
			if(beginningOfQueue > topOfQueue) {
				beginningOfQueue = topOfQueue = -1;
			}
			return result;
		}
	}

Time Complexity:-> O(1)
Space Complexity:-> O(1)

Peeking an Element from Linear Queue:->
	public int peek() {
		if(isEmpty()) {
			System.out.println("The Queue is empty!");
			return -1; 
		}
		else {
			return arr[beginningOfQueue];
		}

	}
	
Time Complexity:-> O(1)
Space Complexity:-> O(1)

Deleting Entire Linear Queue:->
public void deleteLinearQueue() {
		arr = null;
		System.out.println("Linear Queue is successfully deleted");
	}

Time Complexity:-> O(1)
Space Complexity:-> O(1)

------------------------------------------------------------------------------------------------------

Circular Queue With Array:->
-> Linear Queue causes blank cell;
-> In Linear queues with size 5 and we insert all elements and the queue is full. now
if we delete 2 elements then we want to insert new data then queue will be full so 
circular queue solved this problem.

public CircularQueue(int size) {
		this.arr = new int[size];
		this.size = size;
		this.topOfQueue = -1;
		this.beginningOfQueue = -1;
		System.out.println("The CQ is successfully created with size of "+size);
		// TC- O(1) and SC O(N)
	}
	
	public boolean isEmpty() {
		if(topOfQueue == -1) {
			return true;
		}
		else {
			return false;
		}
		//TC: O(1) SC: O(1)
	}
	
	
	 public boolean isFull() {
		 if(topOfQueue+1 == beginningOfQueue ) {
			 return true;
		 }
		 else if(beginningOfQueue == 0 && topOfQueue+1 == size) {
			 return true;
		 }
		 else {
			 return false;
		 }
		 
		 //TC:O(1) SC: O(1)
	 }
	 
	 public void enQueue(int value) {
		 if(isFull()) {
			 System.out.println("The CQ is full!");
		 }
		 else if(isEmpty()) {
			 beginningOfQueue = 0;
			 topOfQueue++;
			 arr[topOfQueue]  = value;
			 System.out.println("Successfully inserted "+value+" in the queue");
		 
		 }
		 else {
			 if(topOfQueue+1 == size) {
				 topOfQueue = 0;
			 }
			 else {
				 topOfQueue++;
			 }
			 arr[topOfQueue] = value;
			 System.out.println("Successfully inserted "+value+" in the queue");
			 //TC:O(1) and SC:O(1)
		 }
	 }
	 
	 
	 public int deQueue() {
		 if(isEmpty()) {
			 System.out.println("The CQ is empty!");
			 return -1;
		 }
		 else {
			 int result = arr[beginningOfQueue];
			 arr[beginningOfQueue] = 0;
			 if(beginningOfQueue == topOfQueue) {
				 beginningOfQueue = topOfQueue = -1;
			 }
			 else if(beginningOfQueue+1 == size) {
				 beginningOfQueue = 0;
			 }
			 else {
				 beginningOfQueue++;
			 }
			 return result;
			 //TC:O(1) and SC:O(1)
		 }
	 }
	 
	 public int peek() {
		 if(isEmpty()) {
			 return -1;
		 }
		 else {
			 return arr[beginningOfQueue];
		 }
		 //TC:O(1) and SC:O(1)
	 }
	 
	 public void delete() {
		 arr = null;
		 System.out.println("Array deleted sucessfully");
		 //TC: O(1) and SC:O(1)
	 }
	
	--------------------------------------------------------------------------------------
	
	
	
	Linear Queue With Linked List:->
	
	
	//Creating Linear Queue
	public LinearQueue(int nodeValue) {
		head = new Node();
		Node node = new Node();
		node.next = null;
		node.value = nodeValue;
		head = node;
		tail = node;
		size = 1;
		System.out.println("Linear Queue Created!");
	}
	
	//Checking is Linear Queue is Empty
	public boolean isEmpty() {
		if(head == null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	//Adding element into the linear Queue
	public void enQueue(int nodeValue) {
		Node node = new Node();
		node.value = nodeValue;
		
		node.next = null;
		tail.next = node;
		tail = node;
		size++;
		System.out.println("Successfully Inserted "+nodeValue+" in the queue");
		
	}
	
	
	//Deleting element from the Linear Queue
	public int deQueue() {
		int value  = -1;
		if(isEmpty()) {
			System.out.println("The Queue is Empty");
		}
		else {
			value = head.value;
			head = head.next;
			size--;
			if (size == 0) {
				tail = null;
			}
		}
		return value;
	}
	
	
	//Accessing the element from the linear queue
	public int peek() {
		if(isEmpty()) {
			System.out.println("The Queue is Empty");
			return -1;
		}
		else {
			return head.value;
		}
	}
	
	
	//Deleting entire Linear Queue
	public void deleteQueue() {
		head = tail = null;
		System.out.println("Entire Queue Deleted Successfully");
	}
	
	------------------------------------------------------------------------------------------------
	
	
    When to use/avoid queue:->
    
    Use
     -> FIFO Functionality
     -> The chance of data corruption is minimum
     
     Avoid
     -> Random access is not possible
	
	
	






















